<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>StarPU Handbook: Data Partition</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">StarPU Handbook
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__API__Data__Partition.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">Data Partition</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structstarpu__data__filter"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="member-group"></a>
Basic API</h2></td></tr>
<tr class="memitem:ga1363109ba0e36c1b6c7f1a40c9608791"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga1363109ba0e36c1b6c7f1a40c9608791">starpu_data_partition</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> initial_handle, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f)</td></tr>
<tr class="memitem:gae80794b9cad7855a3ee54a4361f656ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gae80794b9cad7855a3ee54a4361f656ed">starpu_data_unpartition</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> root_data, unsigned gathering_node)</td></tr>
<tr class="memitem:ga6a3f729055f14384e7397d2815a2c9a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga6a3f729055f14384e7397d2815a2c9a5">starpu_data_get_nb_children</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle)</td></tr>
<tr class="memitem:ga29e07c2c0604da63e7746a8018d8a62f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga29e07c2c0604da63e7746a8018d8a62f">starpu_data_get_child</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle, unsigned i)</td></tr>
<tr class="memitem:gac24101bbe28b1d7d4a0874d349ba8979"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gac24101bbe28b1d7d4a0874d349ba8979">starpu_data_get_sub_data</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> root_data, unsigned depth,...)</td></tr>
<tr class="memitem:ga7904efb86ab3f9d6d682a3a3be3646fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga7904efb86ab3f9d6d682a3a3be3646fe">starpu_data_vget_sub_data</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> root_data, unsigned depth, va_list pa)</td></tr>
<tr class="memitem:ga551d6fa7fead5b9f7c8a85b1f9885e91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga551d6fa7fead5b9f7c8a85b1f9885e91">starpu_data_map_filters</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> root_data, unsigned nfilters,...)</td></tr>
<tr class="memitem:ga15a28291a5045ef7ed3c93afc94ed248"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga15a28291a5045ef7ed3c93afc94ed248">starpu_data_vmap_filters</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> root_data, unsigned nfilters, va_list pa)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="member-group"></a>
Asynchronous API</h2></td></tr>
<tr class="memitem:gaa4407a8734e1fbdbb63b83351769476c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gaa4407a8734e1fbdbb63b83351769476c">starpu_data_partition_plan</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> initial_handle, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, <a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> *children)</td></tr>
<tr class="memitem:ga994cbae9c619b070f8d219f6bfffff06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga994cbae9c619b070f8d219f6bfffff06">starpu_data_partition_submit</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> initial_handle, unsigned nparts, <a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> *children)</td></tr>
<tr class="memitem:ga7fcf158f5196d62610c5017993442c53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga7fcf158f5196d62610c5017993442c53">starpu_data_partition_readonly_submit</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> initial_handle, unsigned nparts, <a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> *children)</td></tr>
<tr class="memitem:ga8a26c673507a7de484071e0926cb5638"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga8a26c673507a7de484071e0926cb5638">starpu_data_partition_readwrite_upgrade_submit</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> initial_handle, unsigned nparts, <a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> *children)</td></tr>
<tr class="memitem:ga46d2b144a7de2e17d17b1383ef5f522d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga46d2b144a7de2e17d17b1383ef5f522d">starpu_data_unpartition_submit</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> initial_handle, unsigned nparts, <a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> *children, int gathering_node)</td></tr>
<tr class="memitem:gac1e66049a48764a29d867a02bcc9d0ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gac1e66049a48764a29d867a02bcc9d0ce">starpu_data_unpartition_readonly_submit</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> initial_handle, unsigned nparts, <a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> *children, int gathering_node)</td></tr>
<tr class="memitem:gac4f0b5ce7cdee16c1311595e9ca53e98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gac4f0b5ce7cdee16c1311595e9ca53e98">starpu_data_partition_clean</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> root_data, unsigned nparts, <a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> *children)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="member-group"></a>
Predefined Vector Filter Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp7fb4f57874a68dd59273529618faf2cd"></a>This section gives a partial list of the predefined partitioning functions for vector data. Examples on how to use them are shown in <a class="el" href="DataManagement.html#PartitioningData">Partitioning Data</a>. The complete list can be found in the file <code><a class="el" href="starpu__data__filters_8h.html">starpu_data_filters.h</a></code>. </p>
</td></tr>
<tr class="memitem:ga212189d3b83dfa4e225609b5f2bf8461"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga212189d3b83dfa4e225609b5f2bf8461">starpu_vector_filter_block</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="memitem:gaab49915dc0462c1b145bfb0a9ce4cf52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gaab49915dc0462c1b145bfb0a9ce4cf52">starpu_vector_filter_block_shadow</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="memitem:gab9fa487bfff5ccdd59210bdde65a11db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gab9fa487bfff5ccdd59210bdde65a11db">starpu_vector_filter_list</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="memitem:gab639622ea4929c36df704a0bebfd3fac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gab639622ea4929c36df704a0bebfd3fac">starpu_vector_filter_divide_in_2</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="member-group"></a>
Predefined Matrix Filter Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp40f9ddfd6d94d60c150ad542d9542fcf"></a>This section gives a partial list of the predefined partitioning functions for matrix data. Examples on how to use them are shown in <a class="el" href="DataManagement.html#PartitioningData">Partitioning Data</a>. The complete list can be found in the file <code><a class="el" href="starpu__data__filters_8h.html">starpu_data_filters.h</a></code>. </p>
</td></tr>
<tr class="memitem:ga8c86b2af9e0806e631c1cbb5d506506b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga8c86b2af9e0806e631c1cbb5d506506b">starpu_matrix_filter_block</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="memitem:ga88fbca61843b76314e39a2c0f8b93d6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga88fbca61843b76314e39a2c0f8b93d6c">starpu_matrix_filter_block_shadow</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="memitem:ga2925be576ac7d597ecead381ff32a894"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga2925be576ac7d597ecead381ff32a894">starpu_matrix_filter_vertical_block</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="memitem:ga7132923bd901e0e4254cc0b20d49997a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga7132923bd901e0e4254cc0b20d49997a">starpu_matrix_filter_vertical_block_shadow</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="member-group"></a>
Predefined Block Filter Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp37648ac3f0915927087c62fb10379c9c"></a>This section gives a partial list of the predefined partitioning functions for block data. Examples on how to use them are shown in <a class="el" href="DataManagement.html#PartitioningData">Partitioning Data</a>. The complete list can be found in the file <code><a class="el" href="starpu__data__filters_8h.html">starpu_data_filters.h</a></code>. A usage example is available in examples/filters/shadow3d.c </p>
</td></tr>
<tr class="memitem:ga1a265ffca51fae58701832a4daa53bd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga1a265ffca51fae58701832a4daa53bd9">starpu_block_filter_block</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="memitem:ga7cc8832e25f2f4049ba5a0053b122dd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga7cc8832e25f2f4049ba5a0053b122dd9">starpu_block_filter_block_shadow</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="memitem:ga73a2c9af1200c68f0403e70e36c020d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga73a2c9af1200c68f0403e70e36c020d0">starpu_block_filter_vertical_block</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="memitem:gafa4818b571e98acd8696a1251b0d4e74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gafa4818b571e98acd8696a1251b0d4e74">starpu_block_filter_vertical_block_shadow</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="memitem:gaae4f93ab3326ded72c3a80d337e6f4a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gaae4f93ab3326ded72c3a80d337e6f4a1">starpu_block_filter_depth_block</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="memitem:gac4b9ec529f67e5c300e7eed3e185fbaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gac4b9ec529f67e5c300e7eed3e185fbaf">starpu_block_filter_depth_block_shadow</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="member-group"></a>
Predefined BCSR Filter Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpd93eeddd2d8e1976c5a8afc351886d12"></a>This section gives a partial list of the predefined partitioning functions for BCSR data. Examples on how to use them are shown in <a class="el" href="DataManagement.html#PartitioningData">Partitioning Data</a>. The complete list can be found in the file <code><a class="el" href="starpu__data__filters_8h.html">starpu_data_filters.h</a></code>. </p>
</td></tr>
<tr class="memitem:ga0e1bee4821237529d554605d333e9109"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga0e1bee4821237529d554605d333e9109">starpu_bcsr_filter_canonical_block</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="memitem:ga554a2fb14fdee9353364c39f36ee3a6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga554a2fb14fdee9353364c39f36ee3a6f">starpu_csr_filter_vertical_block</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<hr/><h2>Data Structure Documentation</h2>
<a name="structstarpu__data__filter" id="structstarpu__data__filter"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct starpu_data_filter</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The filter structure describes a data partitioning operation, to be given to the <a class="el" href="group__API__Data__Partition.html#ga1363109ba0e36c1b6c7f1a40c9608791">starpu_data_partition()</a> function. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a1fe0cc960cc4a6a2db7c2e8295b121ca"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#a1fe0cc960cc4a6a2db7c2e8295b121ca">filter_func</a> )(void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *, unsigned id, unsigned nparts)</td></tr>
<tr class="memitem:aec46586c98b5631201151b7582724e12"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#aec46586c98b5631201151b7582724e12">nchildren</a></td></tr>
<tr class="memitem:aba1a8e13ad0f9c970a30232d583b07b4"><td class="memItemLeft" align="right" valign="top">unsigned(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#aba1a8e13ad0f9c970a30232d583b07b4">get_nchildren</a> )(struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *, <a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> initial_handle)</td></tr>
<tr class="memitem:a930eea80978a13822793f04e93e8a445"><td class="memItemLeft" align="right" valign="top">struct <br class="typebreak"/>
<a class="el" href="group__API__Data__Interfaces.html#structstarpu__data__interface__ops">starpu_data_interface_ops</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#a930eea80978a13822793f04e93e8a445">get_child_ops</a> )(struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *, unsigned id)</td></tr>
<tr class="memitem:a6cb631e64e61f862647040852fdabe49"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#a6cb631e64e61f862647040852fdabe49">filter_arg</a></td></tr>
<tr class="memitem:aeadc5f4c1657e545f2139332321c6450"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#aeadc5f4c1657e545f2139332321c6450">filter_arg_ptr</a></td></tr>
</table>
<h4>Field Documentation</h4>
<a class="anchor" id="a1fe0cc960cc4a6a2db7c2e8295b121ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* starpu_data_filter::filter_func)(void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *, unsigned id, unsigned nparts)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function fills the child_interface structure with interface information for the id-th child of the parent father_interface (among nparts). </p>

</div>
</div>
<a class="anchor" id="aec46586c98b5631201151b7582724e12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned starpu_data_filter::nchildren</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the number of parts to partition the data into. </p>

</div>
</div>
<a class="anchor" id="aba1a8e13ad0f9c970a30232d583b07b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned(* starpu_data_filter::get_nchildren)(struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *, <a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> initial_handle)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This returns the number of children. This can be used instead of nchildren when the number of children depends on the actual data (e.g. the number of blocks in a sparse matrix). </p>

</div>
</div>
<a class="anchor" id="a930eea80978a13822793f04e93e8a445"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__API__Data__Interfaces.html#structstarpu__data__interface__ops">starpu_data_interface_ops</a> *(* starpu_data_filter::get_child_ops)(struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *, unsigned id)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In case the resulting children use a different data interface, this function returns which interface is used by child number id. </p>

</div>
</div>
<a class="anchor" id="a6cb631e64e61f862647040852fdabe49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned starpu_data_filter::filter_arg</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allow to define an additional parameter for the filter function. </p>

</div>
</div>
<a class="anchor" id="aeadc5f4c1657e545f2139332321c6450"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * starpu_data_filter::filter_arg_ptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allow to define an additional pointer parameter for the filter function, such as the sizes of the different parts. </p>

</div>
</div>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="ga1363109ba0e36c1b6c7f1a40c9608791"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>initial_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This requests partitioning one StarPU data initial_handle into several subdata according to the filter <code>f</code>.</p>
<p>Here an example of how to use the function. </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> f = {</div>
<div class="line">        .<a class="code" href="group__API__Data__Partition.html#a1fe0cc960cc4a6a2db7c2e8295b121ca">filter_func</a> = <a class="code" href="group__API__Data__Partition.html#ga8c86b2af9e0806e631c1cbb5d506506b">starpu_matrix_filter_block</a>,</div>
<div class="line">        .nchildren = nslicesx</div>
<div class="line">};</div>
<div class="line"><a class="code" href="group__API__Data__Partition.html#ga1363109ba0e36c1b6c7f1a40c9608791">starpu_data_partition</a>(A_handle, &amp;f);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gae80794b9cad7855a3ee54a4361f656ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_unpartition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>root_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>gathering_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This unapplies one filter, thus unpartitioning the data. The pieces of data are collected back into one big piece in the <code>gathering_node</code> (usually STARPU_MAIN_RAM). Tasks working on the partitioned data must be already finished when calling <a class="el" href="group__API__Data__Partition.html#gae80794b9cad7855a3ee54a4361f656ed">starpu_data_unpartition()</a>.</p>
<p>Here an example of how to use the function. </p>
<div class="fragment"><div class="line"><a class="code" href="group__API__Data__Partition.html#gae80794b9cad7855a3ee54a4361f656ed">starpu_data_unpartition</a>(A_handle, <a class="code" href="group__API__Codelet__And__Tasks.html#ga64855af2ea04f74a1a261724b3b79046">STARPU_MAIN_RAM</a>);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga6a3f729055f14384e7397d2815a2c9a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int starpu_data_get_nb_children </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the number of children. </p>

</div>
</div>
<a class="anchor" id="ga29e07c2c0604da63e7746a8018d8a62f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> starpu_data_get_child </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the ith child of the given <code>handle</code>, which must have been partitionned beforehand. </p>

</div>
</div>
<a class="anchor" id="gac24101bbe28b1d7d4a0874d349ba8979"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> starpu_data_get_sub_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>root_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>After partitioning a StarPU data by applying a filter, <a class="el" href="group__API__Data__Partition.html#gac24101bbe28b1d7d4a0874d349ba8979">starpu_data_get_sub_data()</a> can be used to get handles for each of the data portions. <code>root_data</code> is the parent data that was partitioned. <code>depth</code> is the number of filters to traverse (in case several filters have been applied, to e.g. partition in row blocks, and then in column blocks), and the subsequent parameters are the indexes. The function returns a handle to the subdata.</p>
<p>Here an example of how to use the function. </p>
<div class="fragment"><div class="line">h = <a class="code" href="group__API__Data__Partition.html#gac24101bbe28b1d7d4a0874d349ba8979">starpu_data_get_sub_data</a>(A_handle, 1, taskx);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga7904efb86ab3f9d6d682a3a3be3646fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> starpu_data_vget_sub_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>root_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is similar to <a class="el" href="group__API__Data__Partition.html#gac24101bbe28b1d7d4a0874d349ba8979">starpu_data_get_sub_data()</a> but uses a va_list for the parameter list. </p>

</div>
</div>
<a class="anchor" id="ga551d6fa7fead5b9f7c8a85b1f9885e91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_map_filters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>root_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nfilters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies <code>nfilters</code> filters to the handle designated by <code>root_handle</code> recursively. <code>nfilters</code> pointers to variables of the type <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> should be given. </p>

</div>
</div>
<a class="anchor" id="ga15a28291a5045ef7ed3c93afc94ed248"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_vmap_filters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>root_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nfilters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies <code>nfilters</code> filters to the handle designated by <code>root_handle</code> recursively. It uses a va_list of pointers to variables of the type <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a>. </p>

</div>
</div>
<a class="anchor" id="gaa4407a8734e1fbdbb63b83351769476c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_partition_plan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>initial_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> *&#160;</td>
          <td class="paramname"><em>children</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This plans for partitioning one StarPU data handle <code>initial_handle</code> into several subdata according to the filter <code>f</code>. The handles are returned into the <code>children</code> array, which has to be the same size as the number of parts described in <code>f</code>. These handles are not immediately usable, starpu_data_partition_submit has to be called to submit the actual partitioning.</p>
<p>Here is an example of how to use the function:</p>
<div class="fragment"><div class="line"><a class="code" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> children[nslicesx];</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> f = {</div>
<div class="line">        .<a class="code" href="group__API__Data__Partition.html#a1fe0cc960cc4a6a2db7c2e8295b121ca">filter_func</a> = <a class="code" href="group__API__Data__Partition.html#ga8c86b2af9e0806e631c1cbb5d506506b">starpu_matrix_filter_block</a>,</div>
<div class="line">        .nchildren = nslicesx</div>
<div class="line">};</div>
<div class="line"><a class="code" href="group__API__Data__Partition.html#gaa4407a8734e1fbdbb63b83351769476c">starpu_data_partition_plan</a>(A_handle, &amp;f, children);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga994cbae9c619b070f8d219f6bfffff06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_partition_submit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>initial_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> *&#160;</td>
          <td class="paramname"><em>children</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This submits the actual partitioning of <code>initial_handle</code> into the <code>nparts</code> <code>children</code> handles. This call is asynchronous, it only submits that the partitioning should be done, so that the <code>children</code> handles can now be used to submit tasks, and <code>initial_handle</code> can not be used to submit tasks any more (to guarantee coherency).</p>
<p>For instance,</p>
<div class="fragment"><div class="line"><a class="code" href="group__API__Data__Partition.html#ga994cbae9c619b070f8d219f6bfffff06">starpu_data_partition_submit</a>(A_handle, nslicesx, children);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga7fcf158f5196d62610c5017993442c53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_partition_readonly_submit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>initial_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> *&#160;</td>
          <td class="paramname"><em>children</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the same as starpu_data_partition_submit, but does not invalidate <code>initial_handle</code>. This allows to continue using it, but the application has to be careful not to write to <code>initial_handle</code> or <code>children</code> handles, only read from them, since the coherency is otherwise not guaranteed. This thus allows to submit various tasks which concurrently read from various partitions of the data.</p>
<p>When the application wants to write to <code>initial_handle</code> again, it should call starpu_data_unpartition_submit, which will properly add dependencies between the reads on the <code>children</code> and the writes to be submitted.</p>
<p>If instead the application wants to write to <code>children</code> handles, it should call starpu_data_partition_readwrite_upgrade_submit, which will properly add dependencies between the reads on the <code>initial_handle</code> and the writes to be submitted. </p>

</div>
</div>
<a class="anchor" id="ga8a26c673507a7de484071e0926cb5638"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_partition_readwrite_upgrade_submit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>initial_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> *&#160;</td>
          <td class="paramname"><em>children</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This assumes that a partitioning of <code>initial_handle</code> has already been submited in readonly mode through starpu_data_partition_readonly_submit, and will upgrade that partitioning into read-write mode for the <code>children</code>, by invalidating <code>initial_handle</code>, and adding the necessary dependencies. </p>

</div>
</div>
<a class="anchor" id="ga46d2b144a7de2e17d17b1383ef5f522d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_unpartition_submit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>initial_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> *&#160;</td>
          <td class="paramname"><em>children</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gathering_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This assumes that <code>initial_handle</code> is partitioned into <code>children</code>, and submits an unpartitionning of it, i.e. submitting a gathering of the pieces on the requested <code>gathering_node</code> memory node, and submitting an invalidation of the children.</p>
<p><code>gathering_node</code> can be set to -1 to let the runtime decide which memory node should be used to gather the pieces. </p>

</div>
</div>
<a class="anchor" id="gac1e66049a48764a29d867a02bcc9d0ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_unpartition_readonly_submit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>initial_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> *&#160;</td>
          <td class="paramname"><em>children</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gathering_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This assumes that <code>initial_handle</code> is partitioned into <code>children</code>, and submits just a readonly unpartitionning of it, i.e. submitting a gathering of the pieces on the requested <code>gathering_node</code> memory node. It does not invalidate the children. This brings <code>initial_handle</code> and <code>children</code> handles to the same state as obtained with starpu_data_partition_readonly_submit.</p>
<p><code>gathering_node</code> can be set to -1 to let the runtime decide which memory node should be used to gather the pieces. </p>

</div>
</div>
<a class="anchor" id="gac4f0b5ce7cdee16c1311595e9ca53e98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_partition_clean </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>root_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> *&#160;</td>
          <td class="paramname"><em>children</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This should be used to clear the partition planning established between <code>root_data</code> and <code>children</code> with starpu_data_partition_plan. This will notably submit an unregister all the <code>children</code>, which can thus not be used any more afterwards. </p>

</div>
</div>
<a class="anchor" id="ga212189d3b83dfa4e225609b5f2bf8461"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_vector_filter_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return in <code>child_interface</code> the <code>id</code> th element of the vector represented by <code>father_interface</code> once partitioned in <code>nparts</code> chunks of equal size. </p>

</div>
</div>
<a class="anchor" id="gaab49915dc0462c1b145bfb0a9ce4cf52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_vector_filter_block_shadow </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return in <code>child_interface</code> the <code>id</code> th element of the vector represented by <code>father_interface</code> once partitioned in <code>nparts</code> chunks of equal size with a shadow border <code>filter_arg_ptr</code>, thus getting a vector of size (n-2*shadow)/nparts+2*shadow. The <code>filter_arg_ptr</code> field of <code>f</code> must be the shadow size casted into void*. <b>IMPORTANT</b>: This can only be used for read-only access, as no coherency is enforced for the shadowed parts. An usage example is available in examples/filters/shadow.c </p>

</div>
</div>
<a class="anchor" id="gab9fa487bfff5ccdd59210bdde65a11db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_vector_filter_list </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return in <code>child_interface</code> the <code>id</code> th element of the vector represented by <code>father_interface</code> once partitioned into <code>nparts</code> chunks according to the <code>filter_arg_ptr</code> field of <code>f</code>. The <code>filter_arg_ptr</code> field must point to an array of <code>nparts</code> uint32_t elements, each of which specifies the number of elements in each chunk of the partition. </p>

</div>
</div>
<a class="anchor" id="gab639622ea4929c36df704a0bebfd3fac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_vector_filter_divide_in_2 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return in <code>child_interface</code> the <code>id</code> th element of the vector represented by <code>father_interface</code> once partitioned in <code>2</code> chunks of equal size, ignoring nparts. Thus, <code>id</code> must be <code>0</code> or <code>1</code>. </p>

</div>
</div>
<a class="anchor" id="ga8c86b2af9e0806e631c1cbb5d506506b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_matrix_filter_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This partitions a dense Matrix along the x dimension, thus getting (x/<code>nparts</code> ,y) matrices. If <code>nparts</code> does not divide x, the last submatrix contains the remainder. </p>

</div>
</div>
<a class="anchor" id="ga88fbca61843b76314e39a2c0f8b93d6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_matrix_filter_block_shadow </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This partitions a dense Matrix along the x dimension, with a shadow border <code>filter_arg_ptr</code>, thus getting ((x-2*shadow)/<code>nparts</code> +2*shadow,y) matrices. If <code>nparts</code> does not divide x-2*shadow, the last submatrix contains the remainder. <b>IMPORTANT</b>: This can only be used for read-only access, as no coherency is enforced for the shadowed parts. A usage example is available in examples/filters/shadow2d.c </p>

</div>
</div>
<a class="anchor" id="ga2925be576ac7d597ecead381ff32a894"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_matrix_filter_vertical_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This partitions a dense Matrix along the y dimension, thus getting (x,y/<code>nparts</code>) matrices. If <code>nparts</code> does not divide y, the last submatrix contains the remainder. </p>

</div>
</div>
<a class="anchor" id="ga7132923bd901e0e4254cc0b20d49997a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_matrix_filter_vertical_block_shadow </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This partitions a dense Matrix along the y dimension, with a shadow border <code>filter_arg_ptr</code>, thus getting (x,(y-2*shadow)/<code>nparts</code> +2*shadow) matrices. If <code>nparts</code> does not divide y-2*shadow, the last submatrix contains the remainder. <b>IMPORTANT</b>: This can only be used for read-only access, as no coherency is enforced for the shadowed parts. A usage example is available in examples/filters/shadow2d.c </p>

</div>
</div>
<a class="anchor" id="ga1a265ffca51fae58701832a4daa53bd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_block_filter_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This partitions a block along the X dimension, thus getting (x/<code>nparts</code> ,y,z) 3D matrices. If <code>nparts</code> does not divide x, the last submatrix contains the remainder. </p>

</div>
</div>
<a class="anchor" id="ga7cc8832e25f2f4049ba5a0053b122dd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_block_filter_block_shadow </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This partitions a block along the X dimension, with a shadow border <code>filter_arg_ptr</code>, thus getting ((x-2*shadow)/<code>nparts</code> +2*shadow,y,z) blocks. If <code>nparts</code> does not divide x, the last submatrix contains the remainder. <b>IMPORTANT</b>: This can only be used for read-only access, as no coherency is enforced for the shadowed parts. </p>

</div>
</div>
<a class="anchor" id="ga73a2c9af1200c68f0403e70e36c020d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_block_filter_vertical_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This partitions a block along the Y dimension, thus getting (x,y/<code>nparts</code> ,z) blocks. If <code>nparts</code> does not divide y, the last submatrix contains the remainder. </p>

</div>
</div>
<a class="anchor" id="gafa4818b571e98acd8696a1251b0d4e74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_block_filter_vertical_block_shadow </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This partitions a block along the Y dimension, with a shadow border <code>filter_arg_ptr</code>, thus getting (x,(y-2*shadow)/<code>nparts</code> +2*shadow,z) 3D matrices. If <code>nparts</code> does not divide y, the last submatrix contains the remainder. <b>IMPORTANT</b>: This can only be used for read-only access, as no coherency is enforced for the shadowed parts. </p>

</div>
</div>
<a class="anchor" id="gaae4f93ab3326ded72c3a80d337e6f4a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_block_filter_depth_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This partitions a block along the Z dimension, thus getting (x,y,z/<code>nparts</code>) blocks. If <code>nparts</code> does not divide z, the last submatrix contains the remainder. </p>

</div>
</div>
<a class="anchor" id="gac4b9ec529f67e5c300e7eed3e185fbaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_block_filter_depth_block_shadow </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This partitions a block along the Z dimension, with a shadow border <code>filter_arg_ptr</code>, thus getting (x,y,(z-2*shadow)/<code>nparts</code> +2*shadow) blocks. If <code>nparts</code> does not divide z, the last submatrix contains the remainder. <b>IMPORTANT</b>: This can only be used for read-only access, as no coherency is enforced for the shadowed parts. </p>

</div>
</div>
<a class="anchor" id="ga0e1bee4821237529d554605d333e9109"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_bcsr_filter_canonical_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This partitions a block-sparse matrix into dense matrices. </p>

</div>
</div>
<a class="anchor" id="ga554a2fb14fdee9353364c39f36ee3a6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_csr_filter_vertical_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This partitions a block-sparse matrix into vertical block-sparse matrices. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Dec 17 2015 14:27:40 for StarPU Handbook by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.2 </li>
  </ul>
</div>
</body>
</html>
